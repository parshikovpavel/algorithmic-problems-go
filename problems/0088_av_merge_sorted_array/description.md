# 88. Merge Sorted Array

## Условие задачи

Нужно слить 2 отсортированных *array* в один отсортированный *array*

**Input**

2 отсортированных (по возрастанию) *array*'s `A` и `B` длины `m` и `n`

**Output**

Отсортированный (по возрастанию) *array*, состоящий из элементов первых двух

**Пример 1:**

```
Input: nums1 = [1, 2, 5], nums2 = [1, 2, 3, 4, 6]
Output: [1, 1, 2, 2, 3, 4, 5, 6]
```

**Пример 2:**

```
Input: nums1 = [4, 7, 13], nums2 = [3, 5, 8, 9, 11]
Output: [3, 4, 5, 7, 8, 9, 11, 13]
```

**Алгоритмическая сложность:**

`O(N+M)`



## Решение

[Код](solution.go)

```go
func merge(a []int, b []int) []int {
	resLength := len(a) + len(b)

	res := make([]int, resLength)

	aI := 0
	bI := 0
	resI := 0

	for aI < len(a) && bI < len(b) {
		if a[aI] < b[bI] {
			res[resI] = a[aI]
			aI++
		} else {
			res[resI] = b[bI]
			bI++
		}
		resI++
	}

	copy(res[resI:], a[aI:])
	copy(res[resI:], b[bI:])

	return res
}

```

- заводим указатели `aI`, `bI`, `resI` для определения текущей позиции в двух исходных *array* и результирующем
- двигаемся двумя указателями сразу по обоим массивам `a` и `b` и кладем в результирующий *array* наименьший элемент из двух *array*
- после того как хотя бы один из *array* закончился, функцией `copy()` просто копируем оставшийся хвост другого *array* в результирующий *array* (тут сразу два хвоста копируются, чтобы не писать условие проверки, какой из *array* закончился)

[Тесты](solution_test.go)